### 스파게티 코드를 만드는 원인들 
- **높은 coupling, 지나치게 많은 제어문, 많은 변수의 사용, 추상화 단계의 부재**,  : 10-200룰을 통해서 어느정도 해결 가능하다고 생각함 
### 프로그래밍의 가치와 그 가치를 지키기 위한 원칙들
- 가치
   - 커뮤니케이션 : 프로그래밍에 있어서 가장 중요한 가치 , 읽고 이해시킬 수 없는 코드는 가치가 없다 
   - 단순함 
   - 유연함 : 커뮤니케이션과 단순함을 해치지 않는 범위 안에서 유연함을 추구해야 함 
      (커뮤니케이션/단순함 > 유연함)
- 원칙
    - 지역적 변화 : 코드를 수정할 때, **수정해야 하는 부분은 한 곳에 몰려있어야 함** 
    - 최소 중복 : 중복된 코드가 많다면, 앞서 말한 지역적 변화를 지킬 수 없게 됨 
    - 로직과 데이터의 결합: 로직과 데이터는 한 곳에 유지되는 것이 유리하다, 지역적 변화와도 연관 있음 
    - 대칭성 
    - 선언적 표현: 어떻게 하느냐 보다는 **“무엇을 하느냐**"를 기술 
    - 시간적 대칭성: **같은 타이밍에 수정되어야 할 코드**를 묶어두어야 한다. 
                             **특정 메소드에서만 사용하는 변수는 메소드의 지역 변수로 선언**해라 

### 추상화
- 하나의 함수 내에서도 동일한 수준의 추상화를 사용해야 한다.
- 추상화의 레벨이 들쭉날쭉하면 reader의 입장에서 코드 읽기가 힘들어짐
- reader가 궁금해할 내용, 알아야 할 내용만 기술

### 응집도가 높은 클래스 
- 인스턴스 변수의 수가 적어야 한다 
- 메소드에서 인스턴스 변수를 이용하고 있지 않는다면, 해당 메소드는 그 클래스에서 하지 않아도 될 일을 하고 있을 경우가 높다 ! 
- 하지만, 응집도가 높은 클래스를 유지하는 것은 cost가 큰 일이기 때문에 항상 좋은 방법은 아니다
------------------
### OOP를 잘 이해하기 위한, 5가지 원칙 

### 1. SRP(Single Responsibility principle) 
- 하나의 클래스에서는 하나의 책임만(기능만) 해야 한다
- 책임이라는 것은 변경의 관점에서 봐야한다 
    - 어느 한 기능을 변경하는데 많은 클래스가 수정되거나, 클래스가 많이 수정되지 않으면 srp가 제대로 이루어지지 않은 것
    - 클래스 중심으로 보면, 하나의 클래스가 너무 많은 일을 하는 것
    -  기능 중심으로 보면, 하나의 기능이 여러 클래스에 분산되어 있는 것
- srp를 지키게 되면 자연스럽게 응집성 높아지고 커플링이 낮아짐
- **10-200룰**이 srp를 지키는데 큰 도움이 된다. 
- ios에서 srp를 지키지 않는 경우 -> MVC 패턴 
    - vc에서 너무 많은 일을 하게 된다. 
    - vc의 정의는 **view를 manage**하는 요소인데, 그 이외의 control 작업을 다 도맡아서 하게 됨 
    - 이를 개선하기 위해 등장한 것이 mvp, mvvm, viper 등의 패턴이다 
        - 이 패턴들에서는 **vc를 뷰로 바라본다.**
### 2. OCP(Open Close principle: 개방 폐쇄 원칙) 
- 확장에 대해서는 열려있고, 수정에 대해서는 닫혀있다 
    - 수정/추가를 할 때, 기존의 코드를 손대지 않는다. 
- 코드를 짤 때의 **확장성, 유연성**에 대한 이야기
- ocp는 추상화에 크게 의존한다 
   - **추상화된 클래스를 구체화**해서 사용하면, 기존 코드를 수정하지 않고도 새로운 클래스 생성 가능 **(상속)**
- **if/else 문을 극도로 제한시키는 작업을 통해서 ocp 패턴을 연습 가능**
- ocp의 예시 
   **- Enum타입의 값들을 switch 문이나 분기문을 통해서 판단하고 있다면..** 
       - ocp를 따르고 있지 않을 가능성이 높다. 
       **- 확장에 대해서는 열려있으나, 수정에 대해서 닫혀있지 않다** : switch 문이 쓰이는 모든 곳을 변경해야 하기 때문 
       - switch문을 enum안에다 모아둔다. 
           - 하나의 케이스에 대해 코드가 늘어난다면? -> 10-200룰을 못지키고 , srp도 못지키게됨 
           **- 하나의 protocol로 빼고, 상속해서 쓰는 방법으로 바꿀 것**
- ocp는 만능키가 될 수 없다 
   - Ocp는 유연성을 높이지만, 단순성을 떨어뜨릴 수 있다. 하지만, 프로그래밍의 가치에서 단순성은 유연성보다 앞서기 때문에, 명확히 판단이 어려울 경우에는 변화가 없을 것이라고 가정하고 코딩 -> 나중에 리팩토링

### 3. LSP(Liskov Substitution Principle: 리스코프 치환 원칙)
- 자식 객체는 부모 객체의 역할을 완전히 수행할 수 있어야 한다. 
- 상속을 할 때, 부모의 행위를 자식이 거부하거나, 퇴화 함수를 만들면 안된다. 
    - 퇴화 함수: 부모로부터 상속받은 함수를 실행이 불가능하게 하거나 빈 값을 넣어두는 경우
- ios에서 LSP를 위반하는 사례
    - UIKit 중 view를 상속받는 요소들 중에, 높이 재설정이 불가능한 요소들이 있음
    - 이것이 코딩할 때 치명적인 결함을 주는 것은 아니지만, 이러한 요소들이 많아지면 코딩하기 힘들어진다
**- LSP를 위반할 때 생길 수 있는 문제들** 
   - 코드가 복잡해진다
  - ocp를 사용하는 이유가 없어지게 된다 
   - 부모 클래스에서 자식 클래스를 알고 있어야 함(하위 클래스를 명시해 따로 지정을 해주어야 함)
- LSP 또한 모든 코드에서 적용되는 것은 어렵기 때문에, trade-off를 고려해 적절히 적용해주자.
- LSP는 믿음
- 상속을 확장의 개념보다는 **추상화에 대한 구체화**라고 생각하자.

